name: READ THE ROOM
version: 1
description: Real-time group voting & Movie Battle Arena schema (Supabase/Postgres)

enums:
  vote_room_type:
    - yes-no
    - multiple-choice
    - scale
    - ranked-choice

tables:
  user_profiles:
    pk: id
    refs:
      id: auth.users.id
    columns:
      id: uuid
      username: text, unique
      display_name: text
      avatar_url: text
      bio: text
      total_votes: int, default=0
      total_battles_created: int, default=0
      total_arguments: int, default=0
      reputation_score: int, default=0
      created_at: timestamptz, default=now()
      updated_at: timestamptz, default=now()
      last_seen_at: timestamptz, default=now()
      is_active: boolean, default=true
    triggers:
      - trg_user_profiles_updated_at: before update -> set_updated_at()
    rls:
      - select: is_active=true or id=auth.uid()
      - insert: id=auth.uid()
      - update: id=auth.uid()

  user_sessions:
    pk: id
    columns:
      id: uuid, default=gen_random_uuid()
      user_id: uuid -> auth.users.id
      session_token: text, unique
      ip_address: inet
      user_agent: text
      created_at: timestamptz, default=now()
      expires_at: timestamptz, default=now()+30d
      is_active: boolean, default=true
    rls:
      - all: user_id = auth.uid()

  user_preferences:
    pk: id
    columns:
      id: uuid, default=gen_random_uuid()
      user_id: uuid -> auth.users.id, unique
      theme: text, default=dark
      notifications_enabled: boolean, default=true
      email_notifications: boolean, default=true
      auto_share_votes: boolean, default=false
      preferred_genres: jsonb, default=[]
      privacy_level: text, default=public
      created_at: timestamptz, default=now()
      updated_at: timestamptz, default=now()
    triggers:
      - trg_user_preferences_updated_at: before update -> set_updated_at()
    rls:
      - all: user_id = auth.uid()

  vote_rooms:
    pk: id
    columns:
      id: uuid, default=uuid_generate_v4()
      title: text, not null
      description: text
      category: text
      type: vote_room_type, not null
      items: jsonb
      scale_min: int
      scale_max: int
      deadline: timestamptz
      is_active: boolean, default=true
      created_at: timestamptz, default=now()
      expires_at: timestamptz, default=now()+30d
      created_by: text
      user_id: uuid -> auth.users.id
    checks:
      - if type=scale then scale_min & scale_max required and scale_min <= scale_max
    rls:
      - select: is_active=true or user_id=auth.uid()
      - insert: (auth only) user_id=auth.uid()
      - update: (auth only) user_id=auth.uid()
    indexes:
      - is_active
      - category
      - type
      - expires_at
      - items gin

  votes:
    pk: id
    columns:
      id: uuid, default=gen_random_uuid()
      room_id: uuid -> vote_rooms.id
      value: jsonb, not null
      session_id: text, not null
      created_at: timestamptz, default=now()
      user_id_auth: uuid -> auth.users.id (nullable)
    rls:
      - insert: open (anonymous allowed)
      - select: via active room or owner of room
    indexes:
      - (room_id, created_at desc)

  movie_battles:
    pk: id
    columns:
      id: uuid, default=gen_random_uuid()
      title: text, not null
      description: text
      movie_a_id: int, not null
      movie_a_data: jsonb, not null
      movie_b_id: int, not null
      movie_b_data: jsonb, not null
      created_at: timestamptz, default=now()
      ends_at: timestamptz, not null
      is_active: boolean, default=true
      created_by: text, not null
      total_votes: int, default=0
      user_id: uuid -> auth.users.id
    checks:
      - movie_a_id != movie_b_id
    rls:
      - select: is_active=true or user_id=auth.uid()
      - insert: (auth only) user_id=auth.uid()
      - update: (auth only) user_id=auth.uid()
    indexes:
      - (is_active, ends_at)
      - created_by
      - user_id
      - movie_a_data gin
      - movie_b_data gin

  battle_votes:
    pk: id
    columns:
      id: uuid, default=gen_random_uuid()
      battle_id: uuid -> movie_battles.id
      movie_id: int, not null
      session_id: text, not null
      created_at: timestamptz, default=now()
      user_id_auth: uuid -> auth.users.id (nullable)
    constraints:
      - unique (battle_id, session_id)
      - trigger validate movie_id matches battle
    rls:
      - insert: open (anonymous allowed)
      - select: active battle or owner
    triggers:
      - tally total_votes on movie_battles
      - bump user_profiles.total_votes when user_id_auth present
    indexes:
      - (battle_id, created_at desc)

  battle_arguments:
    pk: id
    columns:
      id: uuid, default=gen_random_uuid()
      battle_id: uuid -> movie_battles.id
      movie_id: int, not null
      user_id: text, not null
      username: text, not null
      content: text, not null, <= 280
      likes: int, default=0
      created_at: timestamptz, default=now()
      user_id_auth: uuid -> auth.users.id (nullable)
    rls:
      - insert: open
      - select: active battle or owner
    indexes:
      - (battle_id, created_at desc)

  argument_likes:
    pk: id
    columns:
      id: uuid, default=gen_random_uuid()
      argument_id: uuid -> battle_arguments.id
      user_id: text, not null
      created_at: timestamptz, default=now()
      user_id_auth: uuid -> auth.users.id (nullable)
    constraints:
      - unique (argument_id, user_id)
    rls:
      - insert: open
      - select: active battle or owner
    indexes:
      - argument_id

views:
  v_room_vote_counts:
    select: |
      select r.id as room_id, r.title, count(v.id) as votes_count
      from public.vote_rooms r
      left join public.votes v on v.room_id = r.id
      group by r.id

  v_battle_vote_breakdown:
    select: |
      select
        b.id as battle_id, b.title, b.movie_a_id, b.movie_b_id,
        sum(case when v.movie_id = b.movie_a_id then 1 else 0 end) as votes_a,
        sum(case when v.movie_id = b.movie_b_id then 1 else 0 end) as votes_b,
        count(*) as total_votes
      from public.movie_battles b
      left join public.battle_votes v on v.battle_id = b.id
      group by b.id